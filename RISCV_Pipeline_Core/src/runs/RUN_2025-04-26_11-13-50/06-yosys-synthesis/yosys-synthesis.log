
 /----------------------------------------------------------------------------\
 |                                                                            |
 |  yosys -- Yosys Open SYnthesis Suite                                       |
 |                                                                            |
 |  Copyright (C) 2012 - 2020  Claire Xenia Wolf <claire@yosyshq.com>         |
 |                                                                            |
 |  Permission to use, copy, modify, and/or distribute this software for any  |
 |  purpose with or without fee is hereby granted, provided that the above    |
 |  copyright notice and this permission notice appear in all copies.         |
 |                                                                            |
 |  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  |
 |  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF          |
 |  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR   |
 |  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES    |
 |  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN     |
 |  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF   |
 |  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.            |
 |                                                                            |
 \----------------------------------------------------------------------------/

 Yosys 0.38 (git sha1 543faed9c8c, clang++ 17.0.6 -fPIC -Os)

Loaded SDC plugin
[TCL: yosys -import] Command name collision: found pre-existing command `cd' -> skip.
[TCL: yosys -import] Command name collision: found pre-existing command `eval' -> skip.
[TCL: yosys -import] Command name collision: found pre-existing command `exec' -> skip.
[TCL: yosys -import] Command name collision: found pre-existing command `read' -> skip.
[TCL: yosys -import] Command name collision: found pre-existing command `trace' -> skip.

1. Executing Liberty frontend: /home/vu/.volare/volare/sky130/versions/bdc9412b3e468c102d01b7cf6337be06ec6e9c9a/sky130A/libs.ref/sky130_fd_sc_hd/lib/sky130_fd_sc_hd__tt_025C_1v80.lib
Imported 428 cell types from liberty file.

2. Executing Verilog-2005 frontend: /home/vu/RISCV_Pipeline_Core/src/Pipeline_Top.v
Parsing SystemVerilog input from `/home/vu/RISCV_Pipeline_Core/src/Pipeline_Top.v' to AST representation.
Generating RTLIL representation for module `\fetch_cycle'.
Generating RTLIL representation for module `\decode_cycle'.
Generating RTLIL representation for module `\execute_cycle'.
Generating RTLIL representation for module `\memory_cycle'.
Generating RTLIL representation for module `\writeback_cycle'.
Generating RTLIL representation for module `\PC_Adder'.
Generating RTLIL representation for module `\PC_Module'.
Generating RTLIL representation for module `\Mux'.
Generating RTLIL representation for module `\Mux_3_by_1'.
Generating RTLIL representation for module `\Instruction_Memory'.
Generating RTLIL representation for module `\ALU_Decoder'.
Generating RTLIL representation for module `\Main_Decoder'.
Generating RTLIL representation for module `\Control_Unit_Top'.
Generating RTLIL representation for module `\Register_File'.
Generating RTLIL representation for module `\Sign_Extend'.
Generating RTLIL representation for module `\ALU'.
Generating RTLIL representation for module `\Data_Memory'.
Generating RTLIL representation for module `\hazard_unit'.
Generating RTLIL representation for module `\Pipeline_top'.
Successfully finished Verilog frontend.

3. Executing HIERARCHY pass (managing design hierarchy).

3.1. Analyzing design hierarchy..
Top module:  \Pipeline_top
Used module:     \hazard_unit
Used module:     \writeback_cycle
Used module:         \Mux
Used module:     \memory_cycle
Used module:         \Data_Memory
Used module:     \execute_cycle
Used module:         \PC_Adder
Used module:         \ALU
Used module:         \Mux_3_by_1
Used module:     \decode_cycle
Used module:         \Sign_Extend
Used module:         \Register_File
Used module:         \Control_Unit_Top
Used module:             \ALU_Decoder
Used module:             \Main_Decoder
Used module:     \fetch_cycle
Used module:         \Instruction_Memory
Used module:         \PC_Module

3.2. Analyzing design hierarchy..
Top module:  \Pipeline_top
Used module:     \hazard_unit
Used module:     \writeback_cycle
Used module:         \Mux
Used module:     \memory_cycle
Used module:         \Data_Memory
Used module:     \execute_cycle
Used module:         \PC_Adder
Used module:         \ALU
Used module:         \Mux_3_by_1
Used module:     \decode_cycle
Used module:         \Sign_Extend
Used module:         \Register_File
Used module:         \Control_Unit_Top
Used module:             \ALU_Decoder
Used module:             \Main_Decoder
Used module:     \fetch_cycle
Used module:         \Instruction_Memory
Used module:         \PC_Module
Removed 0 unused modules.
Renaming module Pipeline_top to Pipeline_top.

4. Generating Graphviz representation of design.
Writing dot description to `/home/vu/RISCV_Pipeline_Core/src/runs/RUN_2025-04-26_11-13-50/06-yosys-synthesis/hierarchy.dot'.
Dumping module Pipeline_top to page 1.

5. Executing TRIBUF pass.

6. Executing HIERARCHY pass (managing design hierarchy).

6.1. Analyzing design hierarchy..
Top module:  \Pipeline_top
Used module:     \hazard_unit
Used module:     \writeback_cycle
Used module:         \Mux
Used module:     \memory_cycle
Used module:         \Data_Memory
Used module:     \execute_cycle
Used module:         \PC_Adder
Used module:         \ALU
Used module:         \Mux_3_by_1
Used module:     \decode_cycle
Used module:         \Sign_Extend
Used module:         \Register_File
Used module:         \Control_Unit_Top
Used module:             \ALU_Decoder
Used module:             \Main_Decoder
Used module:     \fetch_cycle
Used module:         \Instruction_Memory
Used module:         \PC_Module

6.2. Analyzing design hierarchy..
Top module:  \Pipeline_top
Used module:     \hazard_unit
Used module:     \writeback_cycle
Used module:         \Mux
Used module:     \memory_cycle
Used module:         \Data_Memory
Used module:     \execute_cycle
Used module:         \PC_Adder
Used module:         \ALU
Used module:         \Mux_3_by_1
Used module:     \decode_cycle
Used module:         \Sign_Extend
Used module:         \Register_File
Used module:         \Control_Unit_Top
Used module:             \ALU_Decoder
Used module:             \Main_Decoder
Used module:     \fetch_cycle
Used module:         \Instruction_Memory
Used module:         \PC_Module
Removed 0 unused modules.

7. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Removing empty process `Instruction_Memory.$proc$Instruction_Memory.v:0$31'.
Cleaned up 0 empty switches.

8. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Marked 1 switch rules as full_case in process $proc$Data_Memory.v:23$143 in module Data_Memory.
Marked 1 switch rules as full_case in process $proc$Register_File.v:24$88 in module Register_File.
Marked 1 switch rules as full_case in process $proc$PC_Module.v:21$17 in module PC_Module.
Marked 1 switch rules as full_case in process $proc$Memory_Cycle.v:46$14 in module memory_cycle.
Marked 1 switch rules as full_case in process $proc$Execute_Cycle.v:88$11 in module execute_cycle.
Marked 1 switch rules as full_case in process $proc$Decode_Cyle.v:80$9 in module decode_cycle.
Marked 1 switch rules as full_case in process $proc$Fetch_Cycle.v:64$1 in module fetch_cycle.
Removed a total of 0 dead cases.

9. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 31 redundant assignments.
Promoted 8 assignments to connections.

10. Executing PROC_INIT pass (extract init attributes).

11. Executing PROC_ARST pass (detect async resets in processes).
Found async reset \rst in `\memory_cycle.$proc$Memory_Cycle.v:46$14'.
Found async reset \rst in `\execute_cycle.$proc$Execute_Cycle.v:88$11'.
Found async reset \rst in `\decode_cycle.$proc$Decode_Cyle.v:80$9'.
Found async reset \rst in `\fetch_cycle.$proc$Fetch_Cycle.v:64$1'.

12. Executing PROC_ROM pass (convert switches to ROMs).
Converted 0 switches.
<suppressed ~3 debug messages>

13. Executing PROC_MUX pass (convert decision trees to multiplexers).
Creating decoders for process `\Data_Memory.$proc$Data_Memory.v:0$154'.
Creating decoders for process `\Data_Memory.$proc$Data_Memory.v:23$143'.
     1/3: $1$memwr$\mem$Data_Memory.v:26$141_EN[31:0]$149
     2/3: $1$memwr$\mem$Data_Memory.v:26$141_DATA[31:0]$148
     3/3: $1$memwr$\mem$Data_Memory.v:26$141_ADDR[31:0]$147
Creating decoders for process `\Register_File.$proc$Register_File.v:0$104'.
Creating decoders for process `\Register_File.$proc$Register_File.v:24$88'.
     1/3: $1$memwr$\Register$Register_File.v:27$86_EN[31:0]$96
     2/3: $1$memwr$\Register$Register_File.v:27$86_DATA[31:0]$95
     3/3: $1$memwr$\Register$Register_File.v:27$86_ADDR[4:0]$94
Creating decoders for process `\PC_Module.$proc$PC_Module.v:21$17'.
     1/1: $0\PC[31:0]
Creating decoders for process `\memory_cycle.$proc$Memory_Cycle.v:46$14'.
     1/6: $0\ReadDataM_r[31:0]
     2/6: $0\ALU_ResultM_r[31:0]
     3/6: $0\PCPlus4M_r[31:0]
     4/6: $0\RD_M_r[4:0]
     5/6: $0\ResultSrcM_r[0:0]
     6/6: $0\RegWriteM_r[0:0]
Creating decoders for process `\execute_cycle.$proc$Execute_Cycle.v:88$11'.
     1/7: $0\ResultE_r[31:0]
     2/7: $0\RD2_E_r[31:0]
     3/7: $0\PCPlus4E_r[31:0]
     4/7: $0\RD_E_r[4:0]
     5/7: $0\ResultSrcE_r[0:0]
     6/7: $0\MemWriteE_r[0:0]
     7/7: $0\RegWriteE_r[0:0]
Creating decoders for process `\decode_cycle.$proc$Decode_Cyle.v:80$9'.
     1/14: $0\RS2_D_r[4:0]
     2/14: $0\RS1_D_r[4:0]
     3/14: $0\PCPlus4D_r[31:0]
     4/14: $0\PCD_r[31:0]
     5/14: $0\RD_D_r[4:0]
     6/14: $0\Imm_Ext_D_r[31:0]
     7/14: $0\RD2_D_r[31:0]
     8/14: $0\RD1_D_r[31:0]
     9/14: $0\ALUControlD_r[2:0]
    10/14: $0\BranchD_r[0:0]
    11/14: $0\ResultSrcD_r[0:0]
    12/14: $0\MemWriteD_r[0:0]
    13/14: $0\ALUSrcD_r[0:0]
    14/14: $0\RegWriteD_r[0:0]
Creating decoders for process `\fetch_cycle.$proc$Fetch_Cycle.v:64$1'.
     1/3: $0\PCPlus4F_reg[31:0]
     2/3: $0\PCF_reg[31:0]
     3/3: $0\InstrF_reg[31:0]

14. Executing PROC_DLATCH pass (convert process syncs to latches).
No latch inferred for signal `\Data_Memory.$memwr$\mem$Data_Memory.v:32$142_EN' from process `\Data_Memory.$proc$Data_Memory.v:0$154'.
No latch inferred for signal `\Register_File.$memwr$\Register$Register_File.v:34$87_EN' from process `\Register_File.$proc$Register_File.v:0$104'.

15. Executing PROC_DFF pass (convert process syncs to FFs).
Creating register for signal `\Data_Memory.$memwr$\mem$Data_Memory.v:26$141_ADDR' using process `\Data_Memory.$proc$Data_Memory.v:23$143'.
  created $dff cell `$procdff$205' with positive edge clock.
Creating register for signal `\Data_Memory.$memwr$\mem$Data_Memory.v:26$141_DATA' using process `\Data_Memory.$proc$Data_Memory.v:23$143'.
  created $dff cell `$procdff$206' with positive edge clock.
Creating register for signal `\Data_Memory.$memwr$\mem$Data_Memory.v:26$141_EN' using process `\Data_Memory.$proc$Data_Memory.v:23$143'.
  created $dff cell `$procdff$207' with positive edge clock.
Creating register for signal `\Register_File.$memwr$\Register$Register_File.v:27$86_ADDR' using process `\Register_File.$proc$Register_File.v:24$88'.
  created $dff cell `$procdff$208' with positive edge clock.
Creating register for signal `\Register_File.$memwr$\Register$Register_File.v:27$86_DATA' using process `\Register_File.$proc$Register_File.v:24$88'.
  created $dff cell `$procdff$209' with positive edge clock.
Creating register for signal `\Register_File.$memwr$\Register$Register_File.v:27$86_EN' using process `\Register_File.$proc$Register_File.v:24$88'.
  created $dff cell `$procdff$210' with positive edge clock.
Creating register for signal `\PC_Module.\PC' using process `\PC_Module.$proc$PC_Module.v:21$17'.
  created $dff cell `$procdff$211' with positive edge clock.
Creating register for signal `\memory_cycle.\RegWriteM_r' using process `\memory_cycle.$proc$Memory_Cycle.v:46$14'.
  created $adff cell `$procdff$212' with positive edge clock and negative level reset.
Creating register for signal `\memory_cycle.\ResultSrcM_r' using process `\memory_cycle.$proc$Memory_Cycle.v:46$14'.
  created $adff cell `$procdff$213' with positive edge clock and negative level reset.
Creating register for signal `\memory_cycle.\RD_M_r' using process `\memory_cycle.$proc$Memory_Cycle.v:46$14'.
  created $adff cell `$procdff$214' with positive edge clock and negative level reset.
Creating register for signal `\memory_cycle.\PCPlus4M_r' using process `\memory_cycle.$proc$Memory_Cycle.v:46$14'.
  created $adff cell `$procdff$215' with positive edge clock and negative level reset.
Creating register for signal `\memory_cycle.\ALU_ResultM_r' using process `\memory_cycle.$proc$Memory_Cycle.v:46$14'.
  created $adff cell `$procdff$216' with positive edge clock and negative level reset.
Creating register for signal `\memory_cycle.\ReadDataM_r' using process `\memory_cycle.$proc$Memory_Cycle.v:46$14'.
  created $adff cell `$procdff$217' with positive edge clock and negative level reset.
Creating register for signal `\execute_cycle.\RegWriteE_r' using process `\execute_cycle.$proc$Execute_Cycle.v:88$11'.
  created $adff cell `$procdff$218' with positive edge clock and negative level reset.
Creating register for signal `\execute_cycle.\MemWriteE_r' using process `\execute_cycle.$proc$Execute_Cycle.v:88$11'.
  created $adff cell `$procdff$219' with positive edge clock and negative level reset.
Creating register for signal `\execute_cycle.\ResultSrcE_r' using process `\execute_cycle.$proc$Execute_Cycle.v:88$11'.
  created $adff cell `$procdff$220' with positive edge clock and negative level reset.
Creating register for signal `\execute_cycle.\RD_E_r' using process `\execute_cycle.$proc$Execute_Cycle.v:88$11'.
  created $adff cell `$procdff$221' with positive edge clock and negative level reset.
Creating register for signal `\execute_cycle.\PCPlus4E_r' using process `\execute_cycle.$proc$Execute_Cycle.v:88$11'.
  created $adff cell `$procdff$222' with positive edge clock and negative level reset.
Creating register for signal `\execute_cycle.\RD2_E_r' using process `\execute_cycle.$proc$Execute_Cycle.v:88$11'.
  created $adff cell `$procdff$223' with positive edge clock and negative level reset.
Creating register for signal `\execute_cycle.\ResultE_r' using process `\execute_cycle.$proc$Execute_Cycle.v:88$11'.
  created $adff cell `$procdff$224' with positive edge clock and negative level reset.
Creating register for signal `\decode_cycle.\RegWriteD_r' using process `\decode_cycle.$proc$Decode_Cyle.v:80$9'.
  created $adff cell `$procdff$225' with positive edge clock and negative level reset.
Creating register for signal `\decode_cycle.\ALUSrcD_r' using process `\decode_cycle.$proc$Decode_Cyle.v:80$9'.
  created $adff cell `$procdff$226' with positive edge clock and negative level reset.
Creating register for signal `\decode_cycle.\MemWriteD_r' using process `\decode_cycle.$proc$Decode_Cyle.v:80$9'.
  created $adff cell `$procdff$227' with positive edge clock and negative level reset.
Creating register for signal `\decode_cycle.\ResultSrcD_r' using process `\decode_cycle.$proc$Decode_Cyle.v:80$9'.
  created $adff cell `$procdff$228' with positive edge clock and negative level reset.
Creating register for signal `\decode_cycle.\BranchD_r' using process `\decode_cycle.$proc$Decode_Cyle.v:80$9'.
  created $adff cell `$procdff$229' with positive edge clock and negative level reset.
Creating register for signal `\decode_cycle.\ALUControlD_r' using process `\decode_cycle.$proc$Decode_Cyle.v:80$9'.
  created $adff cell `$procdff$230' with positive edge clock and negative level reset.
Creating register for signal `\decode_cycle.\RD1_D_r' using process `\decode_cycle.$proc$Decode_Cyle.v:80$9'.
  created $adff cell `$procdff$231' with positive edge clock and negative level reset.
Creating register for signal `\decode_cycle.\RD2_D_r' using process `\decode_cycle.$proc$Decode_Cyle.v:80$9'.
  created $adff cell `$procdff$232' with positive edge clock and negative level reset.
Creating register for signal `\decode_cycle.\Imm_Ext_D_r' using process `\decode_cycle.$proc$Decode_Cyle.v:80$9'.
  created $adff cell `$procdff$233' with positive edge clock and negative level reset.
Creating register for signal `\decode_cycle.\RD_D_r' using process `\decode_cycle.$proc$Decode_Cyle.v:80$9'.
  created $adff cell `$procdff$234' with positive edge clock and negative level reset.
Creating register for signal `\decode_cycle.\RS1_D_r' using process `\decode_cycle.$proc$Decode_Cyle.v:80$9'.
  created $adff cell `$procdff$235' with positive edge clock and negative level reset.
Creating register for signal `\decode_cycle.\RS2_D_r' using process `\decode_cycle.$proc$Decode_Cyle.v:80$9'.
  created $adff cell `$procdff$236' with positive edge clock and negative level reset.
Creating register for signal `\decode_cycle.\PCD_r' using process `\decode_cycle.$proc$Decode_Cyle.v:80$9'.
  created $adff cell `$procdff$237' with positive edge clock and negative level reset.
Creating register for signal `\decode_cycle.\PCPlus4D_r' using process `\decode_cycle.$proc$Decode_Cyle.v:80$9'.
  created $adff cell `$procdff$238' with positive edge clock and negative level reset.
Creating register for signal `\fetch_cycle.\InstrF_reg' using process `\fetch_cycle.$proc$Fetch_Cycle.v:64$1'.
  created $adff cell `$procdff$239' with positive edge clock and negative level reset.
Creating register for signal `\fetch_cycle.\PCF_reg' using process `\fetch_cycle.$proc$Fetch_Cycle.v:64$1'.
  created $adff cell `$procdff$240' with positive edge clock and negative level reset.
Creating register for signal `\fetch_cycle.\PCPlus4F_reg' using process `\fetch_cycle.$proc$Fetch_Cycle.v:64$1'.
  created $adff cell `$procdff$241' with positive edge clock and negative level reset.

16. Executing PROC_MEMWR pass (convert process memory writes to cells).

17. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Removing empty process `Data_Memory.$proc$Data_Memory.v:0$154'.
Found and cleaned up 1 empty switch in `\Data_Memory.$proc$Data_Memory.v:23$143'.
Removing empty process `Data_Memory.$proc$Data_Memory.v:23$143'.
Removing empty process `Register_File.$proc$Register_File.v:0$104'.
Found and cleaned up 1 empty switch in `\Register_File.$proc$Register_File.v:24$88'.
Removing empty process `Register_File.$proc$Register_File.v:24$88'.
Found and cleaned up 1 empty switch in `\PC_Module.$proc$PC_Module.v:21$17'.
Removing empty process `PC_Module.$proc$PC_Module.v:21$17'.
Removing empty process `memory_cycle.$proc$Memory_Cycle.v:46$14'.
Removing empty process `execute_cycle.$proc$Execute_Cycle.v:88$11'.
Removing empty process `decode_cycle.$proc$Decode_Cyle.v:80$9'.
Removing empty process `fetch_cycle.$proc$Fetch_Cycle.v:64$1'.
Cleaned up 3 empty switches.

18. Executing CHECK pass (checking for obvious problems).
Checking module Pipeline_top...
Checking module hazard_unit...
Checking module Data_Memory...
Checking module ALU...
Checking module Sign_Extend...
Checking module Register_File...
Checking module Control_Unit_Top...
Checking module Main_Decoder...
Checking module ALU_Decoder...
Checking module Instruction_Memory...
Checking module Mux_3_by_1...
Checking module Mux...
Checking module PC_Module...
Checking module PC_Adder...
Checking module writeback_cycle...
Checking module memory_cycle...
Checking module execute_cycle...
Checking module decode_cycle...
Checking module fetch_cycle...
Found and reported 0 problems.

19. Executing OPT_EXPR pass (perform const folding).
Optimizing module Pipeline_top.
Optimizing module hazard_unit.
<suppressed ~12 debug messages>
Optimizing module Data_Memory.
<suppressed ~1 debug messages>
Optimizing module ALU.
<suppressed ~3 debug messages>
Optimizing module Sign_Extend.
<suppressed ~1 debug messages>
Optimizing module Register_File.
<suppressed ~5 debug messages>
Optimizing module Control_Unit_Top.
Optimizing module Main_Decoder.
Optimizing module ALU_Decoder.
<suppressed ~3 debug messages>
Optimizing module Instruction_Memory.
<suppressed ~2 debug messages>
Optimizing module Mux_3_by_1.
<suppressed ~1 debug messages>
Optimizing module Mux.
<suppressed ~1 debug messages>
Optimizing module PC_Module.
<suppressed ~2 debug messages>
Optimizing module PC_Adder.
Optimizing module writeback_cycle.
Optimizing module memory_cycle.
<suppressed ~1 debug messages>
Optimizing module execute_cycle.
<suppressed ~1 debug messages>
Optimizing module decode_cycle.
<suppressed ~1 debug messages>
Optimizing module fetch_cycle.
<suppressed ~7 debug messages>

20. Executing FLATTEN pass (flatten design).
Deleting now unused module hazard_unit.
Deleting now unused module Data_Memory.
Deleting now unused module ALU.
Deleting now unused module Sign_Extend.
Deleting now unused module Register_File.
Deleting now unused module Control_Unit_Top.
Deleting now unused module Main_Decoder.
Deleting now unused module ALU_Decoder.
Deleting now unused module Instruction_Memory.
Deleting now unused module Mux_3_by_1.
Deleting now unused module Mux.
Deleting now unused module PC_Module.
Deleting now unused module PC_Adder.
Deleting now unused module writeback_cycle.
Deleting now unused module memory_cycle.
Deleting now unused module execute_cycle.
Deleting now unused module decode_cycle.
Deleting now unused module fetch_cycle.
<suppressed ~22 debug messages>

21. Executing OPT_EXPR pass (perform const folding).
Optimizing module Pipeline_top.

22. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \Pipeline_top..
Removed 206 unused cells and 457 unused wires.
<suppressed ~439 debug messages>

23. Executing OPT pass (performing simple optimizations).

23.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module Pipeline_top.

23.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\Pipeline_top'.
Removed a total of 0 cells.

23.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \Pipeline_top..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.

23.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \Pipeline_top.
Performed a total of 0 changes.

23.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\Pipeline_top'.
Removed a total of 0 cells.

23.6. Executing OPT_DFF pass (perform DFF optimizations).

23.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \Pipeline_top..
Removed 0 unused cells and 12 unused wires.
<suppressed ~12 debug messages>

23.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module Pipeline_top.

23.9. Rerunning OPT passes. (Maybe there is more to do..)

23.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \Pipeline_top..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.

23.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \Pipeline_top.
Performed a total of 0 changes.

23.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\Pipeline_top'.
Removed a total of 0 cells.

23.13. Executing OPT_DFF pass (perform DFF optimizations).

23.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \Pipeline_top..

23.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module Pipeline_top.

23.16. Finished OPT passes. (There is nothing left to do.)

24. Executing FSM pass (extract and optimize FSM).

24.1. Executing FSM_DETECT pass (finding FSMs in design).

24.2. Executing FSM_EXTRACT pass (extracting FSM from design).

24.3. Executing FSM_OPT pass (simple optimizations of FSMs).

24.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \Pipeline_top..

24.5. Executing FSM_OPT pass (simple optimizations of FSMs).

24.6. Executing FSM_RECODE pass (re-assigning FSM state encoding).

24.7. Executing FSM_INFO pass (dumping all available information on FSM cells).

24.8. Executing FSM_MAP pass (mapping FSMs to basic logic).

25. Executing OPT pass (performing simple optimizations).

25.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module Pipeline_top.

25.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\Pipeline_top'.
Removed a total of 0 cells.

25.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \Pipeline_top..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.

25.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \Pipeline_top.
Performed a total of 0 changes.

25.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\Pipeline_top'.
Removed a total of 0 cells.

25.6. Executing OPT_DFF pass (perform DFF optimizations).

25.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \Pipeline_top..

25.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module Pipeline_top.

25.9. Finished OPT passes. (There is nothing left to do.)

26. Executing WREDUCE pass (reducing word size of cells).

27. Executing PEEPOPT pass (run peephole optimizers).

28. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \Pipeline_top..

29. Executing ALUMACC pass (create $alu and $macc cells).
Extracting $alu and $macc cells in module Pipeline_top:
  created 0 $alu and 0 $macc cells.

30. Executing SHARE pass (SAT-based resource sharing).

31. Executing OPT pass (performing simple optimizations).

31.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module Pipeline_top.

31.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\Pipeline_top'.
Removed a total of 0 cells.

31.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \Pipeline_top..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.

31.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \Pipeline_top.
Performed a total of 0 changes.

31.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\Pipeline_top'.
Removed a total of 0 cells.

31.6. Executing OPT_DFF pass (perform DFF optimizations).

31.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \Pipeline_top..

31.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module Pipeline_top.

31.9. Finished OPT passes. (There is nothing left to do.)

32. Executing MEMORY pass.

32.1. Executing OPT_MEM pass (optimize memories).
Performed a total of 0 transformations.

32.2. Executing OPT_MEM_PRIORITY pass (removing unnecessary memory write priority relations).
Performed a total of 0 transformations.

32.3. Executing OPT_MEM_FEEDBACK pass (finding memory read-to-write feedback paths).

32.4. Executing MEMORY_BMUX2ROM pass (converting muxes to ROMs).

32.5. Executing MEMORY_DFF pass (merging $dff cells to $memrd).

32.6. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \Pipeline_top..

32.7. Executing MEMORY_SHARE pass (consolidating $memrd/$memwr cells).

32.8. Executing OPT_MEM_WIDEN pass (optimize memories where all ports are wide).
Performed a total of 0 transformations.

32.9. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \Pipeline_top..

32.10. Executing MEMORY_COLLECT pass (generating $mem cells).

33. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \Pipeline_top..

34. Executing OPT pass (performing simple optimizations).

34.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module Pipeline_top.

34.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\Pipeline_top'.
Removed a total of 0 cells.

34.3. Executing OPT_DFF pass (perform DFF optimizations).

34.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \Pipeline_top..

34.5. Finished fast OPT passes.

35. Executing MEMORY_MAP pass (converting memories to logic and flip-flops).

36. Executing OPT pass (performing simple optimizations).

36.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module Pipeline_top.

36.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\Pipeline_top'.
Removed a total of 0 cells.

36.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \Pipeline_top..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.

36.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \Pipeline_top.
Performed a total of 0 changes.

36.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\Pipeline_top'.
Removed a total of 0 cells.

36.6. Executing OPT_SHARE pass.

36.7. Executing OPT_DFF pass (perform DFF optimizations).

36.8. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \Pipeline_top..

36.9. Executing OPT_EXPR pass (perform const folding).
Optimizing module Pipeline_top.

36.10. Finished OPT passes. (There is nothing left to do.)

37. Executing TECHMAP pass (map to technology primitives).

37.1. Executing Verilog-2005 frontend: /nix/store/sx2v0i73mn1ih2z1nk61pm9n5gjgpidy-yosys/bin/../share/yosys/techmap.v
Parsing Verilog input from `/nix/store/sx2v0i73mn1ih2z1nk61pm9n5gjgpidy-yosys/bin/../share/yosys/techmap.v' to AST representation.
Generating RTLIL representation for module `\_90_simplemap_bool_ops'.
Generating RTLIL representation for module `\_90_simplemap_reduce_ops'.
Generating RTLIL representation for module `\_90_simplemap_logic_ops'.
Generating RTLIL representation for module `\_90_simplemap_compare_ops'.
Generating RTLIL representation for module `\_90_simplemap_various'.
Generating RTLIL representation for module `\_90_simplemap_registers'.
Generating RTLIL representation for module `\_90_shift_ops_shr_shl_sshl_sshr'.
Generating RTLIL representation for module `\_90_shift_shiftx'.
Generating RTLIL representation for module `\_90_fa'.
Generating RTLIL representation for module `\_90_lcu'.
Generating RTLIL representation for module `\_90_alu'.
Generating RTLIL representation for module `\_90_macc'.
Generating RTLIL representation for module `\_90_alumacc'.
Generating RTLIL representation for module `\$__div_mod_u'.
Generating RTLIL representation for module `\$__div_mod_trunc'.
Generating RTLIL representation for module `\_90_div'.
Generating RTLIL representation for module `\_90_mod'.
Generating RTLIL representation for module `\$__div_mod_floor'.
Generating RTLIL representation for module `\_90_divfloor'.
Generating RTLIL representation for module `\_90_modfloor'.
Generating RTLIL representation for module `\_90_pow'.
Generating RTLIL representation for module `\_90_pmux'.
Generating RTLIL representation for module `\_90_demux'.
Generating RTLIL representation for module `\_90_lut'.
Successfully finished Verilog frontend.

37.2. Continuing TECHMAP pass.
No more expansions possible.
<suppressed ~73 debug messages>

38. Executing OPT pass (performing simple optimizations).

38.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module Pipeline_top.

38.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\Pipeline_top'.
Removed a total of 0 cells.

38.3. Executing OPT_DFF pass (perform DFF optimizations).

38.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \Pipeline_top..

38.5. Finished fast OPT passes.

39. Executing ABC pass (technology mapping using ABC).

39.1. Extracting gate netlist of module `\Pipeline_top' to `<abc-temp-dir>/input.blif'..
Extracted 0 gates and 0 wires to a netlist network with 0 inputs and 0 outputs.
Don't call ABC as there is nothing to map.
Removing temp directory.

40. Executing OPT pass (performing simple optimizations).

40.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module Pipeline_top.

40.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\Pipeline_top'.
Removed a total of 0 cells.

40.3. Executing OPT_DFF pass (perform DFF optimizations).

40.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \Pipeline_top..

40.5. Finished fast OPT passes.

41. Executing HIERARCHY pass (managing design hierarchy).

41.1. Analyzing design hierarchy..
Top module:  \Pipeline_top

41.2. Analyzing design hierarchy..
Top module:  \Pipeline_top
Removed 0 unused modules.

42. Printing statistics.

=== Pipeline_top ===

   Number of wires:                 21
   Number of wire bits:             52
   Number of public wires:          21
   Number of public wire bits:      52
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  0

43. Executing CHECK pass (checking for obvious problems).
Checking module Pipeline_top...
Found and reported 0 problems.

44. Generating Graphviz representation of design.
Writing dot description to `/home/vu/RISCV_Pipeline_Core/src/runs/RUN_2025-04-26_11-13-50/06-yosys-synthesis/primitive_techmap.dot'.
Dumping module Pipeline_top to page 1.

45. Executing OPT pass (performing simple optimizations).

45.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module Pipeline_top.

45.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\Pipeline_top'.
Removed a total of 0 cells.

45.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \Pipeline_top..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.

45.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \Pipeline_top.
Performed a total of 0 changes.

45.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\Pipeline_top'.
Removed a total of 0 cells.

45.6. Executing OPT_DFF pass (perform DFF optimizations).

45.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \Pipeline_top..

45.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module Pipeline_top.

45.9. Finished OPT passes. (There is nothing left to do.)

46. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \Pipeline_top..
Removed 0 unused cells and 19 unused wires.
<suppressed ~19 debug messages>
{
   "creator": "Yosys 0.38 (git sha1 543faed9c8c, clang++ 17.0.6 -fPIC -Os)",
   "invocation": "stat -json -liberty /home/vu/RISCV_Pipeline_Core/src/runs/RUN_2025-04-26_11-13-50/tmp/cd1fccb2abfd40ff9326fde10d952026.lib ",
   "modules": {
      "\\Pipeline_top": {
         "num_wires":         2,
         "num_wire_bits":     2,
         "num_pub_wires":     2,
         "num_pub_wire_bits": 2,
         "num_memories":      0,
         "num_memory_bits":   0,
         "num_processes":     0,
         "num_cells":         0,
         "num_cells_by_type": {

         }
      }
   },
      "design": {
         "num_wires":         2,
         "num_wire_bits":     2,
         "num_pub_wires":     2,
         "num_pub_wire_bits": 2,
         "num_memories":      0,
         "num_memory_bits":   0,
         "num_processes":     0,
         "num_cells":         0,
         "num_cells_by_type": {

         }
      }
}

47. Printing statistics.

=== Pipeline_top ===

   Number of wires:                  2
   Number of wire bits:              2
   Number of public wires:           2
   Number of public wire bits:       2
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  0

mapping tbuf
[INFO] Applying tri-state buffer mapping from '/home/vu/.volare/volare/sky130/versions/bdc9412b3e468c102d01b7cf6337be06ec6e9c9a/sky130A/libs.tech/openlane/sky130_fd_sc_hd/tribuff_map.v'...

48. Executing TECHMAP pass (map to technology primitives).

48.1. Executing Verilog-2005 frontend: /home/vu/.volare/volare/sky130/versions/bdc9412b3e468c102d01b7cf6337be06ec6e9c9a/sky130A/libs.tech/openlane/sky130_fd_sc_hd/tribuff_map.v
Parsing Verilog input from `/home/vu/.volare/volare/sky130/versions/bdc9412b3e468c102d01b7cf6337be06ec6e9c9a/sky130A/libs.tech/openlane/sky130_fd_sc_hd/tribuff_map.v' to AST representation.
Generating RTLIL representation for module `\$_TBUF_'.
Successfully finished Verilog frontend.

48.2. Continuing TECHMAP pass.
No more expansions possible.
<suppressed ~3 debug messages>

49. Executing SIMPLEMAP pass (map simple cells to gate primitives).
[INFO] Applying latch mapping from '/home/vu/.volare/volare/sky130/versions/bdc9412b3e468c102d01b7cf6337be06ec6e9c9a/sky130A/libs.tech/openlane/sky130_fd_sc_hd/latch_map.v'...

50. Executing TECHMAP pass (map to technology primitives).

50.1. Executing Verilog-2005 frontend: /home/vu/.volare/volare/sky130/versions/bdc9412b3e468c102d01b7cf6337be06ec6e9c9a/sky130A/libs.tech/openlane/sky130_fd_sc_hd/latch_map.v
Parsing Verilog input from `/home/vu/.volare/volare/sky130/versions/bdc9412b3e468c102d01b7cf6337be06ec6e9c9a/sky130A/libs.tech/openlane/sky130_fd_sc_hd/latch_map.v' to AST representation.
Generating RTLIL representation for module `\$_DLATCH_P_'.
Generating RTLIL representation for module `\$_DLATCH_N_'.
Successfully finished Verilog frontend.

50.2. Continuing TECHMAP pass.
No more expansions possible.
<suppressed ~4 debug messages>

51. Executing SIMPLEMAP pass (map simple cells to gate primitives).

52. Executing DFFLIBMAP pass (mapping DFF cells to sequential cells from liberty file).
  cell sky130_fd_sc_hd__dfxtp_2 (noninv, pins=3, area=21.27) is a direct match for cell type $_DFF_P_.
  cell sky130_fd_sc_hd__dfrtp_2 (noninv, pins=4, area=26.28) is a direct match for cell type $_DFF_PN0_.
  cell sky130_fd_sc_hd__dfstp_2 (noninv, pins=4, area=26.28) is a direct match for cell type $_DFF_PN1_.
  cell sky130_fd_sc_hd__dfbbn_2 (noninv, pins=6, area=35.03) is a direct match for cell type $_DFFSR_NNN_.
  final dff cell mappings:
    unmapped dff cell: $_DFF_N_
    \sky130_fd_sc_hd__dfxtp_2 _DFF_P_ (.CLK( C), .D( D), .Q( Q));
    unmapped dff cell: $_DFF_NN0_
    unmapped dff cell: $_DFF_NN1_
    unmapped dff cell: $_DFF_NP0_
    unmapped dff cell: $_DFF_NP1_
    \sky130_fd_sc_hd__dfrtp_2 _DFF_PN0_ (.CLK( C), .D( D), .Q( Q), .RESET_B( R));
    \sky130_fd_sc_hd__dfstp_2 _DFF_PN1_ (.CLK( C), .D( D), .Q( Q), .SET_B( R));
    unmapped dff cell: $_DFF_PP0_
    unmapped dff cell: $_DFF_PP1_
    \sky130_fd_sc_hd__dfbbn_2 _DFFSR_NNN_ (.CLK_N( C), .D( D), .Q( Q), .Q_N(~Q), .RESET_B( R), .SET_B( S));
    unmapped dff cell: $_DFFSR_NNP_
    unmapped dff cell: $_DFFSR_NPN_
    unmapped dff cell: $_DFFSR_NPP_
    unmapped dff cell: $_DFFSR_PNN_
    unmapped dff cell: $_DFFSR_PNP_
    unmapped dff cell: $_DFFSR_PPN_
    unmapped dff cell: $_DFFSR_PPP_

52.1. Executing DFFLEGALIZE pass (convert FFs to types supported by the target).
Mapping DFF cells in module `\Pipeline_top':
{
   "creator": "Yosys 0.38 (git sha1 543faed9c8c, clang++ 17.0.6 -fPIC -Os)",
   "invocation": "stat -json -liberty /home/vu/RISCV_Pipeline_Core/src/runs/RUN_2025-04-26_11-13-50/tmp/cd1fccb2abfd40ff9326fde10d952026.lib ",
   "modules": {
      "\\Pipeline_top": {
         "num_wires":         2,
         "num_wire_bits":     2,
         "num_pub_wires":     2,
         "num_pub_wire_bits": 2,
         "num_memories":      0,
         "num_memory_bits":   0,
         "num_processes":     0,
         "num_cells":         0,
         "num_cells_by_type": {

         }
      }
   },
      "design": {
         "num_wires":         2,
         "num_wire_bits":     2,
         "num_pub_wires":     2,
         "num_pub_wire_bits": 2,
         "num_memories":      0,
         "num_memory_bits":   0,
         "num_processes":     0,
         "num_cells":         0,
         "num_cells_by_type": {

         }
      }
}

53. Printing statistics.

=== Pipeline_top ===

   Number of wires:                  2
   Number of wire bits:              2
   Number of public wires:           2
   Number of public wire bits:       2
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  0

[INFO] Using strategy "AREA 0"...

54. Executing ABC pass (technology mapping using ABC).

54.1. Extracting gate netlist of module `\Pipeline_top' to `/tmp/yosys-abc-Gwtsik/input.blif'..
Extracted 0 gates and 0 wires to a netlist network with 0 inputs and 0 outputs.
Don't call ABC as there is nothing to map.
Removing temp directory.

55. Executing SETUNDEF pass (replace undef values with defined constants).

56. Executing HILOMAP pass (mapping to constant drivers).
Warning: Selection "sky130_fd_sc_hd__conb_1" did not match any module.
Warning: Selection "LO" did not match any object.

57. Executing SPLITNETS pass (splitting up multi-bit signals).

58. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \Pipeline_top..

59. Executing INSBUF pass (insert buffer cells for connected wires).

60. Executing CHECK pass (checking for obvious problems).
Checking module Pipeline_top...
Found and reported 0 problems.
{
   "creator": "Yosys 0.38 (git sha1 543faed9c8c, clang++ 17.0.6 -fPIC -Os)",
   "invocation": "stat -json -liberty /home/vu/RISCV_Pipeline_Core/src/runs/RUN_2025-04-26_11-13-50/tmp/cd1fccb2abfd40ff9326fde10d952026.lib ",
   "modules": {
      "\\Pipeline_top": {
         "num_wires":         2,
         "num_wire_bits":     2,
         "num_pub_wires":     2,
         "num_pub_wire_bits": 2,
         "num_memories":      0,
         "num_memory_bits":   0,
         "num_processes":     0,
         "num_cells":         0,
         "num_cells_by_type": {

         }
      }
   },
      "design": {
         "num_wires":         2,
         "num_wire_bits":     2,
         "num_pub_wires":     2,
         "num_pub_wire_bits": 2,
         "num_memories":      0,
         "num_memory_bits":   0,
         "num_processes":     0,
         "num_cells":         0,
         "num_cells_by_type": {

         }
      }
}

61. Printing statistics.

=== Pipeline_top ===

   Number of wires:                  2
   Number of wire bits:              2
   Number of public wires:           2
   Number of public wire bits:       2
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                  0

62. Executing Verilog backend.
Dumping module `\Pipeline_top'.

63. Executing JSON backend.

Warnings: 2 unique messages, 2 total
End of script. Logfile hash: 7d4b0ae60a, CPU: user 1.24s system 0.05s, MEM: 54.17 MB peak
Yosys 0.38 (git sha1 543faed9c8c, clang++ 17.0.6 -fPIC -Os)
Time spent: 49% 7x stat (0 sec), 15% 2x read_liberty (0 sec), ...
